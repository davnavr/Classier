[<RequireQualifiedAccess>]
module Classier.NET.Compiler.ToSource.Print

open System
open Classier.NET.Compiler
open Classier.NET.Compiler.IR

module Ast = Grammar.Ast

type Print = Print of ((string -> unit) -> unit)
// TODO: Make a computation expression for this.

let nothing = Print ignore

let it out (Print p) = p out

let many plist =
    Print (fun prnt ->
        Seq.iter
            (it prnt)
            plist)

let str s = Print (fun prnt -> prnt s)
let strf format = printf format |> str

let line p = many [ p; str "\n" ]

let strl s = str s |> line

let indented by p = many [ String(' ', by) |> str; p ]

let block indent p =
    [
        strl "{"
        indented indent p
        strl "}"
    ]
    |> many

let pclass (acc, gclass: GenClass) =
    fun prnt ->
        seq {
            let minherit =
                match gclass.Syntax.Inheritance with
                | Ast.CanInherit -> String.Empty
                | Ast.MustInherit -> "abstract "
                | Ast.Sealed -> "sealed "

            sprintf
                "%O %sclass %O%O "
                acc
                minherit
                gclass.ClassName
                () // TODO: Print generic arguments.

            match (gclass.Interfaces, gclass.SuperClass) with
            | (SortedSet.Empty, _)
            | (_, Some _) ->
                invalidOp "no impl"
            | _ -> String.Empty
        }
        |> Seq.iter prnt

let pepoint epoint indent =
    match epoint with
    | Some epoint ->
        seq {
            strl "internal static class _Program"

            seq {
                str "private static void Main("
            }
            |> many
            |> block indent
        }
        |> many
    | None -> strl "// No entry point"

let output gtypes epoint indent = // TODO: How will namespaces be included?
    seq {
        strl "// <auto-generated />"
        strl "#pragma warning disable"
        pepoint epoint indent
    }
    |> many
