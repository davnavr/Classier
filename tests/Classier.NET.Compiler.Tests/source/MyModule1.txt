
namespace blah.blah.blah;

use system.reflection.Assembly;

public module Math {
    let myGlobal: long = 42L;
    let aHexadecimalLiteral: int = 0x2A + 0x1F

            // Wow a comment!
                                                        ;
    let aBinaryLiteral: int = 
                0b00101010 * 0B1100_0011;

    let three: uint = 03;
    let myNegative: uint = -7_135_601;
    let errorCode = -0X00ab_1234;

    let PI: decimal = 3.14159265m;

    private myFancyFunction () {
        this.badFormatting().doThisFancyThing (this) (oh, no);

        return (1 + 2) +
               (3 + 4) *
               (5 + 6 / (7 * 8));
    }

    protected badFormatting ()
                                                ()

                                    (thing: some.really.really.long.name.space.name.MyClass)


                                    {
                                    
                                            }

    internal data MyRecord {
        field1: int;
        field2: string;
    }

    public union MyDUnion { // TODO: Change to enum like syntax, use keyword enum instead
        Case1;
        Case2: long;
        Case3: system.reflection.Assembly;
    }

    internal aUnionTest (pickOne: string | int | null) {
        // These are statements
        /*if (Math.badFormatting.thisWillNotCompileButIsSyntacticallyCorrect()) {
          
        }
        else if (true) {
            new System.String ()
        }
        else {
        }*/

        // This is an expression (implicit return).
        let testValue = if (true) {1} else {2};
    }
}
