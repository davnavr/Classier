
namespace blah.blah.blah;

use system.reflection.Assembly;

public module Math {
    let myGlobal: long = 42L;
    let aHexadecimalLiteral: int = 0x2A + 0x1F

            // Wow a comment!
                                                        ;
    let aBinaryLiteral: int = 
                0b00101010 * 0B1100_0011;

    let three: uint = 03;
    let myNegative: uint = -7_135_601;
    let errorCode = -0X00ab_1234;

    let PI: decimal = 3.14159265m;

    private def myFancyFunction () {
        this.badFormatting().doThisFancyThing (this) (oh, no);

        let myLocalFunc (a) {
            a + 5
        }

        return (1 + 2) +
               (3 + 4) *
               (5 + 6 / (7 * 8));
    }

    protected def badFormatting ()
                                                ()

                                    (thing: some.really.really.long.name.space.name.MyClass)


                                    {
                                    
                                            }

    public data class MyRecord (item1: string, item2: int, item3: Some.Fancy.Item);

    public data class RecordWithMembers (item4: boolean) {
        public def myOtherMember () {
          return item4;
        }
    }

    internal def aUnionTest (pickOne: string | int | null) {
        // These are statements
        if (Math.badFormatting.thisWillNotCompileButIsSyntacticallyCorrect()) {
          
        }
        else if (true && false || true) {
            new System.String ()
        }
        else {
        }

        let testValue = if (true) {1} else {2};
        
        // This is an expression (implicit return).
        testValue
    }

    public def functionTest (f: int => int) {
        f(555)
    }
}
